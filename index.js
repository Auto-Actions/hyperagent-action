const core = require('@actions/core');
const github = require('@actions/github');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const fs = require('fs').promises;
const path = require('path');
const simpleGit = require('simple-git');

async function run() {
  try {
    // Get inputs
    const geminiApiKey = core.getInput('gemini-api-key', { required: true });
    const githubToken = core.getInput('github-token', { required: true });
    const outputPath = core.getInput('output-path') || 'generated';
    const programmingLanguage = core.getInput('programming-language') || 'auto-detect';
    const branchName = core.getInput('branch-name') || 'feature/generated-code';
    const createPR = core.getInput('create-pull-request') === 'true';
    const modelName = core.getInput('model-name') || 'gemini-1.5-flash';

    // Get GitHub context
    const context = github.context;
    const octokit = github.getOctokit(githubToken);

    // Verify this is an issue opened or reopened event
    if (context.eventName !== 'issues' || !['opened', 'reopened'].includes(context.payload.action)) {
      core.setFailed('This action should only run on issue opened or reopened events');
      return;
    }

    const issue = context.payload.issue;
    const issueTitle = issue.title;
    const issueBody = issue.body || '';
    const issueNumber = issue.number;

    core.info(`Processing issue #${issueNumber}: ${issueTitle}`);

    // Initialize Gemini AI
    const genAI = new GoogleGenerativeAI(geminiApiKey);
    const model = genAI.getGenerativeModel({ model: modelName });

    // Create comprehensive prompt for code generation
    const prompt = createCodeGenerationPrompt(issueTitle, issueBody, programmingLanguage);
    
    core.info('Generating code with Gemini API...');
    
    // Generate code using Gemini
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const generatedContent = response.text();

    // Parse the generated content to extract files
    const files = parseGeneratedContent(generatedContent);
    
    if (files.length === 0) {
      throw new Error('No code files were generated from the AI response');
    }

    core.info(`Generated ${files.length} file(s)`);

    // Setup git
    const git = simpleGit();
    
    // Configure git
    await git.addConfig('user.name', 'Gemini Code Generator');
    await git.addConfig('user.email', 'action@github.com');

    // Create and checkout new branch
    const timestamp = Date.now();
    const uniqueBranchName = `${branchName}-${issueNumber}-${timestamp}`;
    
    await git.checkoutLocalBranch(uniqueBranchName);

    // Create output directory
    await fs.mkdir(outputPath, { recursive: true });

    const generatedFiles = [];

    // Write generated files
    for (const file of files) {
      const filePath = path.join(outputPath, file.filename);
      const fileDir = path.dirname(filePath);
      
      // Ensure directory exists
      await fs.mkdir(fileDir, { recursive: true });
      
      // Write file content
      await fs.writeFile(filePath, file.content, 'utf8');
      generatedFiles.push(filePath);
      
      core.info(`Created file: ${filePath}`);
    }

    // Create README for the generated code
    const readmePath = path.join(outputPath, 'README.md');
    const readmeContent = createReadmeContent(issueTitle, issueBody, issueNumber, files);
    await fs.writeFile(readmePath, readmeContent, 'utf8');
    generatedFiles.push(readmePath);

    // Add files to git
    await git.add('.');
    
    // Commit changes
    const commitMessage = `Generate code for issue #${issueNumber}: ${issueTitle}

Generated by Gemini AI based on issue requirements.
This commit contains ${files.length} generated file(s).

Issue: #${issueNumber}
Generated at: ${new Date().toISOString()}`;

    await git.commit(commitMessage);

    // Push branch
    await git.push('origin', uniqueBranchName);

    const commitSha = await git.revparse(['HEAD']);

    core.info(`Pushed code to branch: ${uniqueBranchName}`);

    let pullRequestUrl = null;

    // Create pull request if requested
    if (createPR) {
      const prTitle = `ðŸ¤– Generated code for issue #${issueNumber}: ${issueTitle}`;
      const prBody = `This pull request contains code automatically generated by the Gemini AI based on issue #${issueNumber}.

## Generated Files
${files.map(f => `- \`${f.filename}\``).join('\n')}

## Original Issue
${issueBody}

---
*This PR was automatically created by the Gemini Code Generator action.*`;

      const pullRequest = await octokit.rest.pulls.create({
        owner: context.repo.owner,
        repo: context.repo.repo,
        title: prTitle,
        body: prBody,
        head: uniqueBranchName,
        base: 'main'
      });

      pullRequestUrl = pullRequest.data.html_url;
      core.info(`Created pull request: ${pullRequestUrl}`);

      // Add comment to original issue
      await octokit.rest.issues.createComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: issueNumber,
        body: `ðŸ¤– I've generated code based on your issue! Check out the pull request: ${pullRequestUrl}`
      });
    }

    // Set outputs
    core.setOutput('generated-files', generatedFiles.join(','));
    core.setOutput('pull-request-url', pullRequestUrl || '');
    core.setOutput('commit-sha', commitSha);

    core.info('Action completed successfully!');

  } catch (error) {
    core.setFailed(`Action failed: ${error.message}`);
  }
}

function createCodeGenerationPrompt(title, body, language) {
  return `You are a professional software developer. Based on the following software idea/requirement, generate complete, functional code.

**Title:** ${title}

**Description:** ${body}

**Programming Language:** ${language === 'auto-detect' ? 'Choose the most appropriate language' : language}

Please generate complete, production-ready code with the following structure:
1. Main application files
2. Configuration files if needed
3. Documentation/comments explaining the code
4. Basic error handling

Format your response with clear file separations using this format:
\`\`\`filename:path/to/file.ext
[file content here]
\`\`\`

Make sure to:
- Write clean, maintainable code
- Include appropriate comments
- Add basic error handling
- Follow best practices for the chosen language
- Create a working implementation that addresses the requirements

Generate all necessary files to make this a functional project.`;
}

function parseGeneratedContent(content) {
  const files = [];
  const filePattern = /```(?:filename:)?([\w\-./]+\.[\w]+)?\n([\s\S]*?)```/g;
  let match;

  while ((match = filePattern.exec(content)) !== null) {
    let filename = match[1];
    const fileContent = match[2].trim();

    // If no filename specified, try to infer from content or use default
    if (!filename) {
      filename = inferFilename(fileContent);
    }

    if (filename && fileContent) {
      files.push({
        filename: filename,
        content: fileContent
      });
    }
  }

  return files;
}

function inferFilename(content) {
  // Basic inference logic - can be enhanced
  if (content.includes('def ') || content.includes('import ')) return 'main.py';
  if (content.includes('function ') || content.includes('const ')) return 'index.js';
  if (content.includes('class ') && content.includes('public static void')) return 'Main.java';
  if (content.includes('#include')) return 'main.cpp';
  if (content.includes('package main')) return 'main.go';
  return 'generated_file.txt';
}

function createReadmeContent(title, body, issueNumber, files) {
  return `# Generated Code: ${title}

This code was automatically generated based on GitHub issue #${issueNumber}.

## Original Issue Description
${body}

## Generated Files
${files.map(f => `- \`${f.filename}\``).join('\n')}

## How to Use
[Add specific usage instructions here based on the generated code]

## Generated Information
- **Generated at:** ${new Date().toISOString()}
- **Issue:** #${issueNumber}
- **Generated by:** Gemini Code Generator Action

---
*This code was automatically generated using AI. Please review and test before using in production.*`;
}

// Run the action
run();

module.exports = { run };